{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}

module App where

import           Control.Applicative
import           Control.Monad
import           Control.Monad.Reader
import           Control.Monad.State
import           Data.Bifunctor
import           Data.Binary               hiding (get, put)
import qualified Data.ByteString           as BS
import qualified Data.ByteString.Lazy      as BL
import qualified Data.Map.Strict           as Map
import           Data.Maybe
import           Data.Text                 (Text)
import qualified Data.Text                 as T
import qualified Data.Text.IO              as TIO
import           Data.Version
import           Prettyprinter
import           Prettyprinter.Render.Text
import           System.Console.GetOpt
import           System.Exit
import           System.FilePath
import           System.IO

import qualified Paths_kpp_tool
import           Preset

-- | The kpp-tool version, exported from the Paths module
-- automatically generated by Cabal.
kppToolVersion :: Version
kppToolVersion = Paths_kpp_tool.version

breakOn :: Eq a => a -> [a] -> Maybe ([a], [a])
breakOn c = go []
  where
    go xs (y:ys) | c /= y    = go (y:xs) ys
                 | otherwise = Just (reverse xs, ys)
    go _ _                   = Nothing

commaSep :: String -> [String]
commaSep [] = []
commaSep xs = uncurry (:) . second (commaSep . drop 1) . break (== ',') $ xs

-- | FromArgument is a class for types that can be parsed from a
-- string argument to a CLI option, e.g. --some-flag=<ARG>.
class FromArgument a where
  fromArgument :: String -> Either String a

-- | The same as `fromArgument` but calls `error` on failure.
fromArgument_ :: FromArgument a => String -> a
fromArgument_ s = case fromArgument s of
  Right v  -> v
  Left err -> error err

instance FromArgument String where
  fromArgument = pure

instance FromArgument Text where
  fromArgument = pure . T.pack

instance FromArgument ParamValue where
  fromArgument arg = case breakOn ':' arg of
    Just ("string",   val) -> Right $ String (T.pack val)
    Just ("internal", val) -> Right $ Internal (T.pack val)
    Just ("binary",   val) -> Binary <$> decodeBase64 (T.pack val)
    _                      -> Left "expected TYPE:VALUE"

instance (FromArgument k, FromArgument a) => FromArgument (k, a) where
  fromArgument arg = case breakOn '=' arg of
    Just (key, val) -> (,) <$> fromArgument key <*> fromArgument val
    Nothing         -> Left "expected KEY=VALUE"

instance (Ord k, FromArgument k, FromArgument a) => FromArgument (Map.Map k a) where
  fromArgument = fmap Map.fromList . traverse fromArgument . commaSep

data RunConfig = RunConfig
  { runInputPath  :: Maybe FilePath
  , runOverwrite  :: Bool
  , runQuiet      :: Bool
  , runOperations :: [Op]
  }

defaults :: RunConfig
defaults = RunConfig
  { runInputPath  = Nothing
  , runOverwrite  = False
  , runQuiet      = False
  , runOperations = []
  }

data RunMode = HelpMode
             | VersionMode
             | RunMode RunConfig

mapConfig :: (RunConfig -> RunConfig) -> RunMode -> RunMode
mapConfig f (RunMode x) = RunMode (f x)
mapConfig _ HelpMode    = HelpMode
mapConfig _ VersionMode = VersionMode

setHelpMode :: RunMode -> RunMode
setHelpMode _ = HelpMode

setVersionMode :: RunMode -> RunMode
setVersionMode HelpMode = HelpMode
setVersionMode _        = VersionMode

addOperation :: Op -> RunMode -> RunMode
addOperation op = mapConfig $ \config@RunConfig{..} ->
  config { runOperations = op : runOperations }

type Op = StateT Preset (ReaderT RunConfig IO) ()

runOp :: Op -> RunConfig -> Preset -> IO Preset
runOp op = flip $ runReaderT . execStateT op

-- | Save a `Resource` to file. An optional output path can be
-- provided; otherwise, the resource's filename property is used.
writeResource :: Maybe FilePath -> Resource -> Op
writeResource mpath Resource{..} = do
  RunConfig{..} <- lift ask

  -- If no output path was specified, we inform the user where the
  -- output will be written.
  unless (runQuiet || isJust mpath) $
    liftIO $ putStrLn $ "Writing resource data to: " <> path

  liftIO $ BS.writeFile path resourceData
  where
    path = fromMaybe (T.unpack resourceFile) mpath

op_info :: Op
op_info = do
  preset <- get
  liftIO $ putDoc (pretty preset)
  liftIO $ putChar '\n'

op_getName :: Op
op_getName = do
  name <- gets presetName
  liftIO $ TIO.putStrLn name

op_setName :: Text -> Op
op_setName = modify' . setPresetName

op_getParam :: Text -> Op
op_getParam key = do
  preset <- get
  case lookupParam key preset of
    Just val -> liftIO $ putDoc (pretty val) *> putChar '\n'
    Nothing  -> fail $ "no such parameter: " <> T.unpack key

op_setParam :: (Text, ParamValue) -> Op
op_setParam = modify' . uncurry insertParam

op_extract :: Map.Map Text Text -> Op
op_extract opts = do
  let mpath = T.unpack <$> Map.lookup "path" opts
      lookupResource preset =
        (Map.lookup "name" opts >>= flip lookupResourceByName preset) <|>
        (Map.lookup "file" opts >>= flip lookupResourceByFile preset) <|>
        (Map.lookup "md5"  opts >>= flip lookupResourceByMD5  preset)

  preset <- get
  case lookupResource preset of
    Just resource -> writeResource mpath resource
    Nothing       -> fail "extract: no matching resource found"

op_extractAll :: Op
op_extractAll = do
  resources <- gets embeddedResources
  mapM_ (writeResource Nothing) resources

op_embed :: Map.Map Text Text -> Op
op_embed opts = do
  preset <- get

  -- TODO: This can probably be simplified by using a second internal
  -- "do" block and constructing the Resource using RecordWildCards.
  rData <- liftIO $ traverse BS.readFile (T.unpack <$> rPath)
  case Resource <$> rName <*> rFile <*> rType <*> rData of
    Just resource -> put $ insertResource resource preset
    Nothing       -> fail "insert: invalid resource definition"
  where
    rPath = Map.lookup "path" opts <|> Map.lookup "file" opts
    rType = Map.lookup "type" opts
    rName = Map.lookup "name" opts <|> rPath
    rFile = Map.lookup "file" opts <|> rPath

op_getIcon :: FilePath -> Op
op_getIcon path = do
  icon <- gets getPresetIcon
  liftIO $ BL.writeFile path icon

op_setIcon :: FilePath -> Op
op_setIcon path = do
  pngData <- liftIO $ BL.readFile path
  preset <- get
  case setPresetIcon pngData preset of
    Right preset' -> put preset'
    Left  err     -> fail $ "set-icon: " <> err

op_output :: FilePath -> Op
op_output path = do
  preset <- get
  liftIO $ savePreset path preset

op_syncName :: Op
op_syncName = do
  RunConfig{..} <- lift ask
  case runInputPath of
    Just path -> op_setName $ T.pack (takeBaseName path)
    Nothing   -> error "--sync-name requires an input path"

-- | Command Line Options
options :: [OptDescr (RunMode -> RunMode)]
options = [ Option "h" ["help"]
            (NoArg setHelpMode)
            "Display help and usage information."
          , Option "v" ["version"]
            (NoArg setVersionMode)
            "Display version information."

          -- Global Options
          , Option "O" ["overwrite"]
            (NoArg $ mapConfig $ \c -> c { runOverwrite = True })
            "Modify a preset file in-place."
          , Option "q" ["quiet"]
            (NoArg $ mapConfig $ \c -> c { runQuiet = True })
            "Supress unnecessary output."

          -- Operations
          , Option "o" ["output"]
            (ReqArg (addOperation . op_output . fromArgument_) "PATH")
            "Write preset data to PATH."
          , Option "i" ["info"]
            (NoArg  (addOperation op_info))
            "Print a description of a preset."
          , Option "n" ["get-name"]
            (NoArg  (addOperation op_getName))
            "Print a preset's metadata name."
          , Option "N" ["set-name"]
            (ReqArg (addOperation . op_setName . fromArgument_) "STRING")
            "Change a preset's metadata name."
          , Option "S" ["sync-name"]
            (NoArg (addOperation op_syncName))
            "Change a preset's metadata name to match it's filename.\n\
            \For example, 'kpp-tool --sync-name foobar.kpp' will change\n\
            \the preset's name to \"foobar\"."
          , Option "p" ["get-param"]
            (ReqArg (addOperation . op_getParam . fromArgument_) "KEY")
            "Print the value of a single parameter.\n\
            \If the value is binary, it will be displayed in base-64."
          , Option "P" ["set-param"]
            (ReqArg (addOperation . op_setParam . fromArgument_) "KEY=TYPE:VALUE")
            "Set the value of a parameter.\n\
            \TYPE can be 'string', 'internal', or 'binary'.\n\
            \For binary parameters, VALUE should be encoded in base-64."
          , Option "x" ["extract"]
            (ReqArg (addOperation . op_extract . fromArgument_) "KEY=VALUE[,...]")
            "Extract an embedded resource."
          , Option "X" ["extract-all"]
            (NoArg  (addOperation op_extractAll))
            "Extract all embedded resources."
          , Option "e" ["embed"]
            (ReqArg (addOperation . op_embed . fromArgument_) "KEY=VALUE[,...]")
            "Insert or update a resource file."
          , Option "c" ["get-icon"]
            (ReqArg (addOperation . op_getIcon . fromArgument_) "PATH")
            "Extract a preset's PNG icon image."
          , Option "C" ["set-icon"]
            (ReqArg (addOperation . op_setIcon . fromArgument_) "PATH")
            "Change a preset's icon image.\n\
            \FILE must be a PNG file."
          ]

run :: RunMode -> IO ()
run HelpMode    = putStrLn $ usageInfo "kpp-tool" options
run VersionMode = putStrLn $ "kpp-tool " <> showVersion kppToolVersion
run (RunMode config@RunConfig{..}) = do
  let source  = maybe BS.getContents BS.readFile runInputPath
      parse   = pure . decode . BL.fromStrict
      process = runOp (sequence_ runOperations) config
      render  = pure . encode
      sink    = when runOverwrite . maybe BL.putStr BL.writeFile runInputPath

  source >>= parse >>= process >>= render >>= sink

-- | `start` is the primary entrypoint of the application, intended to
-- be called by `main`. It expects a list of command line arguments.
start :: [String] -> IO ()
start args = do
  let (flags, posArgs, errs) = getOpt RequireOrder options args

  -- if parsing CLI arguments failed
  unless (null errs) $ do
    hPutStr stderr $ unlines errs
    exitFailure

  let settings = foldr (.) id flags $
        RunMode defaults { runInputPath = listToMaybe posArgs }

  run settings
